<!DOCTYPE html>
<html lang="en">

  {% include head.html %}
  <style>
    /* Styles from shihgptmd.html */
    body { font-family: sans-serif; /* Existing body styles might be in main.css */ }
    .shihgptmd-container { max-width: 900px; margin: 20px auto; padding: 20px; border: 1px solid #ccc; border-radius: 8px; text-align: center; /* Center Rosetta and copyright */ }
    .shihgptmd-container h1 { margin-bottom: 5px; } /* Reduce space after Rosetta */
    .copyright-rosetta { font-size: 0.8em; color: #777; margin-bottom: 20px; display: block; } /* Style for copyright */
    .shihgptmd-container > *:not(h1):not(.copyright-rosetta):not(.checkbox-area):not(div[style*="text-align: center"]) { text-align: left; } /* Reset text-align for other elements, keep title div centered */
    .hidden { display: none !important; } /* Added !important to ensure override */
    .shihgptmd-container label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
    .shihgptmd-container textarea, .shihgptmd-container select { width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
    .shihgptmd-container button { padding: 4px 8px; background-color: #f0f0f0; color: #333; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 0.8em; }
    .shihgptmd-container button:hover { background-color: #ddd !important; }
    .text-hidden-on-white { color: white !important; background-color: white !important; border-color: white !important; }
    #mainOutputArea, #patientInfoInput, #epicSmartPhraseInput { min-height: 150px; }
    .checkbox-area label { font-weight: normal; display: inline-block; margin-right: 15px;}
    .section-title { margin-top: 20px; margin-bottom:10px; font-size: 1.2em; border-bottom: 1px solid #eee; padding-bottom: 5px;}
    summary.section-title { display: list-item; cursor: pointer; }

    #checkboxOptionsContainer div.checkbox-option-item { display: inline-flex; align-items: center; margin-right: 10px; margin-bottom: 2px; }
    #checkboxOptionsContainer input[type="checkbox"] { margin-right: 2px; transform: scale(0.9); vertical-align: middle; }
    #checkboxOptionsContainer h4 { margin-top: 8px; margin-bottom: 2px; font-size: 1.05em; }
    #checkboxOptionsContainer div.checkbox-option-item label { font-weight: normal !important; margin-left: 2px !important; margin-right: 6px !important; line-height: 1.3; font-size: 0.95em; }
    #checkboxOptionsContainer div.checkbox-option-item { margin-right: 6px; margin-bottom: 0px; padding: 1px 0; }

    .apple-switch-label { position: relative; display: inline-block; width: 50px; height: 28px; margin-left: 10px; }
    .apple-switch-checkbox { opacity: 0; width: 0; height: 0; }
    .apple-switch-label::before { content: ""; position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
    .apple-switch-label::after { content: ""; position: absolute; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
    .apple-switch-checkbox:checked + .apple-switch-label::before { background-color: #2196F3; }
    .apple-switch-checkbox:checked + .apple-switch-label::after { transform: translateX(22px); }
    .checkbox-area { display: flex; align-items: center; margin-bottom: 15px;}
    .checkbox-area > label[for="hideTextCheckbox"] { font-weight: bold; margin-right: 8px; order: -1; }

    #incognitoControl { position: absolute; top: 25px; right: 25px; display: flex; align-items: center; z-index: 10; }
    #incognitoControl > label[for="hideTextCheckbox"] { font-weight: bold; margin-right: 8px; font-size: 0.9em; }

    #generatePromptButton { padding: 10px 15px; border-radius: 4px; border: none; background-color: transparent; color: #333; cursor: pointer; font-size: 1.5em; line-height: 1; text-align: center; margin-top: 20px; display: block; margin-left: auto; margin-right: auto; }
    #generatePromptButton:hover { color: #0056b3; }

    #refreshNotesButton_rosetta { padding: 5px 10px; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0; color: #333; cursor: pointer; font-size: 0.9em; line-height: 1; min-width: auto; }
    #refreshNotesButton_rosetta:hover { background-color: #ddd; }

    .rosetta-secondary-button { padding: 5px 10px; font-size: 0.9em; cursor: pointer; background-color: #f0f0f0; color: #333; border: 1px solid #ccc; border-radius: 4px; }
    .rosetta-secondary-button:hover { background-color: #ddd !important; border-color: #bbb; }

    /* Styles for Documentation Modal Content */
    #rosettaDocumentationContent { text-align: left; background: #f9f9f9; border: 1px solid #eee; padding: 15px; border-radius: 4px; line-height: 1.6; }
    #rosettaDocumentationContent h1, #rosettaDocumentationContent h2, #rosettaDocumentationContent h3, #rosettaDocumentationContent h4 { margin-top: 1em; margin-bottom: 0.5em; }
    #rosettaDocumentationContent p { margin-bottom: 0.8em; }
    #rosettaDocumentationContent ul, #rosettaDocumentationContent ol { margin-left: 20px; margin-bottom: 0.8em; }
    #rosettaDocumentationContent li { margin-bottom: 0.3em; }
    #rosettaDocumentationContent code { background-color: #e8e8e8; padding: 2px 4px; border-radius: 3px; font-family: monospace; }
    #rosettaDocumentationContent pre { background-color: #e8e8e8; padding: 10px; border-radius: 3px; overflow-x: auto; }
    #rosettaDocumentationContent pre code { background-color: transparent; padding: 0; }
    #rosettaDocumentationContent blockquote { border-left: 3px solid #ccc; margin-left: 0; padding-left: 10px; color: #555; }
    #rosettaDocumentationContent table { border-collapse: collapse; width: auto; margin-bottom: 1em; }
    #rosettaDocumentationContent th, #rosettaDocumentationContent td { border: 1px solid #ccc; padding: 6px 10px; text-align: left; }
    #rosettaDocumentationContent th { background-color: #f0f0f0; }

  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="{{ site.baseurl }}/">
          <h2 class="nav-title">{{ site.title }}</h2>
        </a>
        <div class="password-entry-container">
          <input type="password" id="secret-password" placeholder="Password">
          <button onclick="checkPassword()">Enter</button>
        </div>
        <ul>
          <li class="nav-link-about"><a href="{{ '/' | prepend: site.baseurl }}">About</a></li>
          <li><a href="{{ '/portfolio' | prepend: site.baseurl }}/">Fun Stuff</a></li>
        </ul>
    </div>
  </nav>

    <main id="mainPageContent">
      {{ content }}
    </main>

    <!-- Documentation Modal Structure -->
    <div id="rosettaDocumentationModal" class="hidden" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 2000; padding: 20px;">
        <div style="background-color: white; padding: 25px; border-radius: 8px; max-width: 800px; max-height: 90vh; overflow-y: auto; position: relative;">
            <button id="closeDocModalButton" style="position: absolute; top: 10px; right: 10px; background: #eee; border: 1px solid #ccc; border-radius: 50%; width: 30px; height: 30px; font-size: 16px; line-height: 1; cursor: pointer;">&times;</button>
            <h2>Rosetta Documentation</h2>
            <div id="rosettaDocumentationContent"> {/* Removed inline styles for raw text */}
                Loading documentation...
            </div>
        </div>
    </div>

    <div id="shihGptMdAppContainer" class="shihgptmd-container hidden" style="position: relative;">
        <div id="incognitoControl">
            <input type="checkbox" id="hideTextCheckbox" name="hideTextCheckbox" class="apple-switch-checkbox">
            <label for="hideTextCheckbox" class="apple-switch-label" aria-hidden="true" style="width: 50px; height: 28px;"></label>
        </div>
        
        <div style="text-align: center; margin-bottom: 5px;">
            <h1 style="margin-bottom: 0; display: inline-block; vertical-align: middle;">Rosetta</h1>
            <button type="button" id="rosettaHelpButton" title="Help / Documentation" style="background: none; border: none; color: #333; font-size: 0.9em; padding: 0 0 0 5px; margin-left: 5px; vertical-align: middle; cursor: pointer;">
                <i class="fas fa-info-circle"></i>
            </button>
        </div>
        <span class="copyright-rosetta" style="margin-top: 0px;">&copy; Philip Shih 2025</span>

        <details open class="section-container">
            <summary class="section-title">Input</summary>
            <div id="inputSectionContent" style="position: relative;">
                <textarea id="patientInfoInput" placeholder="Add input here..." style="padding-right: 120px;"></textarea>
                <button type="button" id="deidentifyPatientInfoBtn" class="rosetta-secondary-button" style="position: absolute; top: 5px; right: 5px; z-index: 5;" title="De-identify Input Text">
                    <i class="fas fa-user-shield"></i> De-identify
                </button>
                <div id="updateNoteUIContainer_rosetta" style="margin-top: 15px; margin-bottom: 15px; padding: 10px; border: 1px solid #eee; border-radius: 4px; text-align: left;">
                    <input type="checkbox" id="enableUpdateModeCheckbox_rosetta" name="enableUpdateModeCheckbox_rosetta" style="margin-right: 5px;">
                    <label for="enableUpdateModeCheckbox_rosetta" style="font-weight: normal; display: inline;">Update existing file?</label>
                    
                    <div id="existingNotesControls_rosetta" class="hidden" style="margin-top: 10px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <select id="existingNotesDropdown_rosetta" style="flex-grow: 1; margin-bottom: 0; min-width: 150px;">
                            </select>
                            <button type="button" id="refreshNotesButton_rosetta" title="Refresh Notes List">
                              <i class="fas fa-redo" style="font-size: 0.8em;"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </details>

        <details class="section-container" id="templateSection">
            <summary class="section-title">Template (Optional)</summary>
            <div id="smartPhraseSectionContent">
                <label for="templateSelector" style="font-weight: bold; margin-bottom: 5px; display: block;">Manual:</label>
                <select id="templateSelector" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; margin-bottom: 5px;">
                </select>
                <div style="margin-top: 5px; margin-bottom: 15px;">
                    <button type="button" id="editSelectedManualButton" class="rosetta-secondary-button hidden" style="margin-right: 5px;">Edit</button>
                    <button type="button" id="deleteSelectedManualButton" class="rosetta-secondary-button hidden" style="background-color: #dc3545; color: white;">Delete</button>
                </div>
                <hr style="margin: 15px 0;">
                <label for="epicSmartPhraseInput" style="font-weight: bold; margin-bottom: 5px; display: block;">Custom Template:</label>
                <textarea id="epicSmartPhraseInput" placeholder="Insert template (SmartPhrase, previous note, etc.)..."></textarea>
                <div style="margin-top: 5px;">
                    <button type="button" id="saveChangesToManualButton" class="rosetta-secondary-button apple-button-like hidden" style="margin-right: 5px;">Save Changes</button>
                    <button type="button" id="saveAsNewManualButton" class="rosetta-secondary-button apple-button-like" style="margin-right: 5px;">Save as New Manual</button>
                    <button type="button" id="clearCustomTemplateButton" class="rosetta-secondary-button apple-button-like">Clear</button>
                </div>
            </div>
        </details>

        <details class="section-container">
            <summary class="section-title">Options</summary> 
            <div id="optionsSectionContent">
                <div id="checkboxOptionsContainer" style="margin-bottom: 20px; text-align: left;"> 
                </div>
                {/* Custom filename input moved here */}
                <div style="margin-top: 15px; margin-bottom: 10px;"> 
                    <label for="customNoteFilenameInput" style="font-size: 0.9em; margin-bottom: 3px; display: block; text-align: left; font-weight: bold;">Custom Filename (optional):</label>
                    <input type="text" id="customNoteFilenameInput" placeholder="e.g., consult_note_smith_20240529" style="width: 100%; padding: 6px; font-size: 0.9em; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box;">
                </div>
            </div>
        </details>

        <button id="generatePromptButton" title="Generate Output"><i class="fas fa-angle-right"></i></button>

        <details class="section-container"> 
            <summary class="section-title">Output</summary>
            <div id="impressionSectionContent">
                <textarea id="modelImpressionArea" placeholder="Output will appear here..." readonly style="min-height: 100px; background-color: #f8f9fa;"></textarea>
            </div>
        </details>

        <details open class="section-container"> 
            <summary class="section-title">Note</summary>
            <div id="noteSectionContent" style="position: relative;"> {/* Ensure this parent has position: relative for the absolute positioned button */}
                <textarea id="mainOutputArea" placeholder="Note will appear here..." readonly style="margin-bottom: 10px;"></textarea> {/* Added more margin-bottom */}
                {/* Copy button moved back to its original positioning context */}
                <button type="button" id="copyNoteButton" class="rosetta-secondary-button" style="position: absolute; top: 5px; right: 5px; z-index: 5;" title="Copy Note to Clipboard">
                    <i class="fas fa-copy"></i> Copy
                </button>
            </div>
        </details>
        
        <details open class="section-container" id="serverSavedNotesSection">
            <summary class="section-title">Saved Notes</summary>
            <div id="serverNotesListArea" style="margin-top: 10px;">
                <button type="button" id="refreshServerNotesListButton" class="rosetta-secondary-button" style="margin-bottom: 10px; margin-right: 5px;" title="Refresh Saved Notes List">
                    <i class="fas fa-redo" style="font-size: 0.8em;"></i>
                </button>
                <button type="button" id="deleteAllNotesButton" class="rosetta-secondary-button" style="margin-bottom: 10px; background-color: #dc3545; color: white;" title="Delete All Saved Notes">
                    <i class="fas fa-trash-alt"></i> Delete All Notes
                </button>
                <ul id="serverNotesDisplayList" style="list-style-type: none; padding-left: 0; max-height: 300px; overflow-y: auto; border: 1px solid #eee; padding: 10px; border-radius: 4px;">
                    <li id="serverNotesLoadingMsg">Loading notes...</li>
                </ul>
            </div>
        </details>
    </div>

    <footer>
      <span>
        &copy;  {{ site.author.name }} <time datetime="{{ site.time }}">{{ site.time | date: '%Y' }}</time>
      </span>
    </footer>

    <script>
      const ROSETTA_BACKEND_URL = 'https://rosetta-backend.onrender.com'; 

      function checkPassword() {
        const passwordInput = document.getElementById('secret-password');
        const password = passwordInput.value;
        const correctPassword = 'E916!'; 

        if (password === correctPassword) {
          document.getElementById('mainPageContent').classList.add('hidden');
          document.getElementById('shihGptMdAppContainer').classList.remove('hidden');
          initializeShihGptMdApp(); 
        } else {
          alert('Incorrect password.');
        }
        passwordInput.value = ''; 
      }

      document.getElementById('secret-password').addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
          event.preventDefault(); 
          checkPassword();
        }
      });

      async function rosettaDeidentifyInputText() {
          const patientInfoTextarea = document.getElementById('patientInfoInput'); 
          const deidentifyButton = document.getElementById('deidentifyPatientInfoBtn'); 
          if (!patientInfoTextarea || !deidentifyButton) {
              console.error("De-identify Error: patientInfoTextarea or deidentifyButton not found in base.html.");
              return;
          }
          const originalText = patientInfoTextarea.value;
          if (!originalText.trim()) {
              alert("Input text is empty. Nothing to de-identify.");
              return;
          }
          const rosettaBackendUrl = ROSETTA_BACKEND_URL; 
          deidentifyButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
          deidentifyButton.disabled = true;
          try {
              const response = await fetch(`${rosettaBackendUrl}/api/deidentify_text`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', },
                  body: JSON.stringify({ text_content: originalText }),
              });
              deidentifyButton.innerHTML = '<i class="fas fa-user-shield"></i> De-identify';
              deidentifyButton.disabled = false;
              if (response.ok) {
                  const data = await response.json();
                  patientInfoTextarea.value = data.deidentified_text;
                  alert("Text de-identified successfully!");
              } else {
                  const errorData = await response.json();
                  alert(`De-identification failed: ${errorData.error} - ${errorData.details || ''}`);
              }
          } catch (error) {
              deidentifyButton.innerHTML = '<i class="fas fa-user-shield"></i> De-identify';
              deidentifyButton.disabled = false;
              alert(`An error occurred: ${error.message}`);
          }
      }

      function initializeShihGptMdApp() {
        const ROSETTA_APP_BACKEND_URL = ROSETTA_BACKEND_URL; 
        let currentlyEditingManualFilename = null; // Variable to store the name of the manual being edited

        const deidentifyBtnBase = document.getElementById('deidentifyPatientInfoBtn');
        if (deidentifyBtnBase) {
            deidentifyBtnBase.addEventListener('click', rosettaDeidentifyInputText);
        }

        async function fetchExistingNotesRosetta() {
            const notesDropdown = document.getElementById('existingNotesDropdown_rosetta');
            if (!notesDropdown) return;
            const previouslySelected = notesDropdown.value;
            notesDropdown.innerHTML = '<option value="" disabled>Loading notes...</option>';
            try {
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/list_saved_notes`, { cache: 'no-store' });
                notesDropdown.innerHTML = ''; 
                if (!response.ok) {
                    const errorOption = document.createElement('option');
                    errorOption.textContent = "Error loading notes"; errorOption.disabled = true;
                    notesDropdown.appendChild(errorOption); return;
                }
                const data = await response.json();
                if (data.notes && data.notes.length > 0) {
                    data.notes.forEach(noteFile => {
                        const option = document.createElement('option');
                        option.value = noteFile; option.textContent = noteFile;
                        notesDropdown.appendChild(option);
                    });
                    if (previouslySelected && notesDropdown.querySelector(`option[value="${previouslySelected}"]`)) {
                        notesDropdown.value = previouslySelected;
                    } else { notesDropdown.selectedIndex = 0; }
                } else {
                     const noNotesOpt = document.createElement('option');
                     noNotesOpt.textContent = data.error || "No notes found"; noNotesOpt.disabled = true;
                     notesDropdown.appendChild(noNotesOpt);
                }
            } catch (error) {
                notesDropdown.innerHTML = ''; 
                const networkErrorOpt = document.createElement('option');
                networkErrorOpt.textContent = "Network error"; networkErrorOpt.disabled = true;
                notesDropdown.appendChild(networkErrorOpt);
            }
        }
        window.fetchExistingNotesRosetta = fetchExistingNotesRosetta;

        async function loadSelectedNoteContent(filename, targetAreaId = 'mainOutputArea') {
            const outputArea = document.getElementById(targetAreaId);
            if (!outputArea || !filename) return;
            outputArea.value = `Loading content for ${filename}...`;
            try {
                const encodedFilename = encodeURIComponent(filename); 
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/get_note/${encodedFilename}`);
                if (!response.ok) {
                    outputArea.value = `Error: Failed to load note. Status: ${response.status}`; return;
                }
                outputArea.value = await response.text();
                const noteSection = document.getElementById('noteSectionContent');
                if (noteSection) noteSection.scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                outputArea.value = `Network error loading note.\nDetails: ${error.message}`;
            }
        }

        async function displaySavedNotesList() {
            const listElement = document.getElementById('serverNotesDisplayList');
            if (!listElement) {
                console.error("Error: Could not find serverNotesDisplayList element.");
                return; 
            }

            // Get or create the status message element
            let statusMessageElement = listElement.querySelector('#serverNotesLoadingMsg');
            if (!statusMessageElement) {
                statusMessageElement = document.createElement('li');
                statusMessageElement.id = 'serverNotesLoadingMsg';
                // This element will be added to listElement after clearing.
            }

            statusMessageElement.textContent = "Loading notes...";
            listElement.innerHTML = ''; // Clear whatever was there (old notes or old status)
            listElement.appendChild(statusMessageElement); // Add/re-add the "Loading notes..." message

            try {
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/list_saved_notes`, { cache: 'no-store' });

                if (!response.ok) {
                    let errorMsg = `Error loading notes: ${response.statusText}`; // Default error
                    try {
                        // Try to parse error details from backend if available
                        const errorData = await response.json();
                        errorMsg = `Error: ${errorData.error || response.statusText}`;
                    } catch (e) {
                        // Ignore if parsing error body fails, stick to default
                    }
                    statusMessageElement.textContent = errorMsg;
                    return;
                }

                const data = await response.json(); // Parse JSON only if response.ok

                if (data.notes && data.notes.length > 0) {
                    listElement.innerHTML = ''; // Clear the "Loading notes..." message
                    data.notes.forEach(filename => {
                        const listItem = document.createElement('li');
                        listItem.textContent = filename;
                        listItem.style.cursor = "pointer"; listItem.style.padding = "5px 0"; listItem.style.borderBottom = "1px solid #f0f0f0";
                        listItem.addEventListener('mouseover', () => listItem.style.backgroundColor = '#f9f9f9');
                        listItem.addEventListener('mouseout', () => listItem.style.backgroundColor = 'transparent');
                        listItem.addEventListener('click', () => loadSelectedNoteContent(filename, 'mainOutputArea'));
                        listElement.appendChild(listItem);
                    });
                } else {
                    statusMessageElement.textContent = data.error || "No saved notes found on server.";
                    // statusMessageElement is already in listElement and will display this.
                }
            } catch (error) {
                console.error("Network error in displaySavedNotesList:", error);
                statusMessageElement.textContent = `Network error loading notes. ${error.message}`;
                // statusMessageElement is already in listElement.
            }
        }

        async function saveCustomTemplate(isNewFile) {
            const templateContent = document.getElementById('epicSmartPhraseInput').value;
            if (!templateContent.trim()) { alert("Template content is empty."); return; }

            let fullFilename;
            if (isNewFile) {
                let userFilename = prompt("Enter new template name (e.g., 'my_progress_note').\n.txt will be added automatically.", "my_new_template");
                if (!userFilename || !userFilename.trim()) return; // User cancelled or entered empty
                userFilename = userFilename.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
                if (!userFilename) { alert("Invalid filename."); return; }
                fullFilename = `${userFilename}.txt`;
            } else { // Saving changes to an existing, loaded manual
                if (!currentlyEditingManualFilename) {
                    alert("No manual loaded for saving. Use 'Edit Selected Manual' first or 'Save as New Manual'.");
                    return;
                }
                fullFilename = currentlyEditingManualFilename;
            }

            try {
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/save_smartphrase_template`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({ filename: fullFilename, content: templateContent }),
                });
                const result = await response.json();
                alert(response.ok ? `Template '${result.filename || fullFilename}' saved successfully.` : `Error saving template: ${result.error}`);
                if (response.ok) {
                    populatePredefinedTemplatesDropdown(); // Refresh dropdown
                    // After any successful save (new or overwrite), reset the editing state
                    currentlyEditingManualFilename = null;
                    const saveChangesButton = document.getElementById('saveChangesToManualButton');
                    if (saveChangesButton) {
                        saveChangesButton.textContent = 'Save Changes';
                        saveChangesButton.classList.add('hidden');
                        saveChangesButton.disabled = true;
                    }
                    // Optionally, reset the main dropdown to "None" to avoid confusion
                    // const templateSelector = document.getElementById('templateSelector');
                    // if (templateSelector) templateSelector.value = "none";
                    // if (editManualButton) editManualButton.classList.add('hidden');
                }
            } catch (error) { alert(`Network error while saving template: ${error.message}`); }
        }

        async function populatePredefinedTemplatesDropdown() {
            const templateSelector = document.getElementById('templateSelector');
            if (!templateSelector) return;
            templateSelector.innerHTML = '<option value="none">None (Use General Structure)</option><option value="" disabled>Loading...</option>';
            try {
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/list_smartphrase_templates`);
                const loadingOpt = templateSelector.querySelector('option[value=""]');
                if(loadingOpt) templateSelector.removeChild(loadingOpt);
                if (!response.ok) {
                    templateSelector.appendChild(Object.assign(document.createElement('option'), {textContent: "Error loading", disabled: true}));
                    templateSelector.value = "none"; return;
                }
                const data = await response.json();
                if (data.templates && data.templates.length > 0) {
                    data.templates.forEach(filename => {
                        if (filename.endsWith('.txt')) {
                            const value = filename.slice(0, -4); 
                            let displayText = value.replace(/[_-]/g, ' ').replace(/\b\w/g, c => c.toUpperCase()); 
                            templateSelector.appendChild(Object.assign(document.createElement('option'), {value: value, textContent: displayText}));
                        }
                    });
                    templateSelector.value = templateSelector.querySelector('option[value="general_soap"]') ? 'general_soap' : 'none';
                } else { 
                    templateSelector.value = "none"; 
                }

                // After setting the dropdown value, update button visibility
                const editBtn = document.getElementById('editSelectedManualButton');
                const deleteBtn = document.getElementById('deleteSelectedManualButton');
                if (templateSelector.value && templateSelector.value !== "none") {
                    if(editBtn) editBtn.classList.remove('hidden');
                    if(deleteBtn) deleteBtn.classList.remove('hidden');
                } else {
                    if(editBtn) editBtn.classList.add('hidden');
                    if(deleteBtn) deleteBtn.classList.add('hidden');
                }

            } catch (error) {
                if (templateSelector.querySelector('option[value=""]')) templateSelector.removeChild(templateSelector.querySelector('option[value=""]'));
                templateSelector.appendChild(Object.assign(document.createElement('option'), {textContent: "Network error", disabled: true}));
                templateSelector.value = "none";
                // Ensure buttons are hidden on error too
                const editBtn = document.getElementById('editSelectedManualButton');
                const deleteBtn = document.getElementById('deleteSelectedManualButton');
                if(editBtn) editBtn.classList.add('hidden');
                if(deleteBtn) deleteBtn.classList.add('hidden');
            }
        }

        const checkboxOptions = [
            { id: "genSHN", label: "SHN", group: "Output" }, { id: "genVSHN", label: "VSHN", group: "Output" },
            { id: "formatByProblem", label: "A&P", group: "Output", checked: true },
            { id: "incPathophys", label: "Pathophysiology", group: "Reasoning" }, { id: "incGuidelines", label: "Guideline Citations", group: "Reasoning" },
            { id: "formatSOAP", label: "SOAP", group: "Documentation", checked: true }, { id: "formatHnP", label: "H&P", group: "Documentation" },
            { id: "formatDischarge", label: "Discharge Summary", group: "Documentation" }, { id: "formatPreOp", label: "Pre-op Note", group: "Documentation" },
            { id: "specAnesthesia", label: "Anesthesia", group: "Context" }, { id: "specDerm", label: "Dermatology", group: "Context" },
            { id: "specFM", label: "Family Medicine", group: "Context" }, { id: "specIM", label: "Internal Medicine", group: "Context" },
            { id: "specNeuro", label: "Neuro", group: "Context" }, { id: "specOBGYN", label: "OBGYN", group: "Context" },
            { id: "specPeds", label: "Pediatrics", group: "Context" }, { id: "specPsych", label: "Psychiatry", group: "Context" },
            { id: "specSurgeryGen", label: "Surgery (General)", group: "Context" },
            { id: "genHistoryQuestions", label: "History", group: "Features" }, { id: "genPEManeuvers", label: "Physical Exam", group: "Features" },
            { id: "genROSTemplate", label: "ROS", group: "Features" }, { id: "genChartReview", label: "Chart Review", group: "Features" },
            { id: "incMissingData", label: "Missing Data", group: "Features" },
            { id: "confirmDeidentified", label: "Identification", group: "Security", checked: true }, 
            { id: "removeDates", label: "Relative Time", group: "Security", checked: true }, 
            { id: "stripNonStandardAbbr", label: "Use Input Abbreviations", group: "Security", checked: true } 
        ];

        function populateCheckboxOptions() {
            const container = document.getElementById('checkboxOptionsContainer');
            if (!container) return; container.innerHTML = ''; 
            let currentGroup = "";
            checkboxOptions.forEach(opt => {
                if (opt.group !== currentGroup) {
                    currentGroup = opt.group;
                    const groupTitle = document.createElement('h4');
                    groupTitle.textContent = currentGroup; groupTitle.style.marginTop = '15px'; groupTitle.style.marginBottom = '5px';
                    container.appendChild(groupTitle);
                }
                const checkbox = Object.assign(document.createElement('input'), {type:'checkbox', id:opt.id, name:opt.id, value:opt.id, checked:opt.checked});
                const labelEl = Object.assign(document.createElement('label'), {htmlFor:opt.id, textContent:opt.label, style:"font-weight:normal;"});
                const div = Object.assign(document.createElement('div'), {className:'checkbox-option-item'});
                div.appendChild(checkbox); div.appendChild(labelEl); container.appendChild(div);
            });
        }

        function getSelectedServiceAbbreviation() {
            const contextCheckboxes = [
                { id: "specAnesthesia", abbr: "ANES" }, { id: "specDerm", abbr: "DERM" }, { id: "specFM", abbr: "FM" },
                { id: "specIM", abbr: "IM" }, { id: "specNeuro", abbr: "NEURO" }, { id: "specOBGYN", abbr: "OBGYN" },
                { id: "specPeds", abbr: "PEDS" }, { id: "specPsych", abbr: "PSYCH" }, { id: "specSurgeryGen", abbr: "SURG" }
            ];
            for (const spec of contextCheckboxes) {
                const checkbox = document.getElementById(spec.id);
                if (checkbox && checkbox.checked) return spec.abbr;
            }
            return "GENERAL";
        }

        async function submitPromptToBackend() {
            const patientInfo = document.getElementById('patientInfoInput').value;
            const epicSmartPhrase = document.getElementById('epicSmartPhraseInput').value;
            const selectedTemplate = document.getElementById('templateSelector').value;
            const outputArea = document.getElementById('mainOutputArea');
            const modelImpressionDisplayArea = document.getElementById('modelImpressionArea');
            const customFilenameInput = document.getElementById('customNoteFilenameInput');

            if (!outputArea || !modelImpressionDisplayArea || !customFilenameInput) { alert("UI elements missing for note generation or saving."); return; }
            outputArea.value = "Processing..."; modelImpressionDisplayArea.value = "Processing...";
            let patient_info_content = (document.getElementById('enableUpdateModeCheckbox_rosetta')?.checked && document.getElementById('existingNotesDropdown_rosetta')?.value && patientInfo.trim() === "") ? "(No new clinical information provided - this is a reformat or option-change request for an existing note)" : patientInfo;
            let template_content_for_payload = ""; let selected_template_name_for_payload = "";
            if (epicSmartPhrase.trim() !== "") {
                template_content_for_payload = epicSmartPhrase; selected_template_name_for_payload = "custom_from_input";
            } else if (selectedTemplate && selectedTemplate !== "none") {
                const templateFileName = `${selectedTemplate}.txt`;
                selected_template_name_for_payload = document.getElementById('templateSelector').options[document.getElementById('templateSelector').selectedIndex].text;
                try {
                    const response = await fetch(`smartphrase_templates/${templateFileName}`);
                    template_content_for_payload = response.ok ? await response.text() : `(Error loading template: ${templateFileName}, Status: ${response.status})`;
                } catch (error) { template_content_for_payload = `(Error loading template: ${templateFileName}, Error: ${error})`; }
            } else { selected_template_name_for_payload = "None (Use General Structure)"; }
            const structuredOptions = {}; checkboxOptions.forEach(opt => { const cb = document.getElementById(opt.id); if(cb) structuredOptions[opt.id] = cb.checked; });
            const serviceAbbreviation = getSelectedServiceAbbreviation();
            const customFilename = customFilenameInput.value.trim();
            const payload = { 
                patient_data: patient_info_content, 
                template_name: selected_template_name_for_payload, 
                template_value: selectedTemplate, 
                template_content: template_content_for_payload, 
                options: structuredOptions, 
                service_abbreviation: serviceAbbreviation,
                custom_filename: customFilename // Add custom filename to payload
            };
            const enableUpdateCheckbox = document.getElementById('enableUpdateModeCheckbox_rosetta');
            const existingNotesDropdown = document.getElementById('existingNotesDropdown_rosetta');
            if (enableUpdateCheckbox?.checked && existingNotesDropdown?.value) payload.existing_note_filename = existingNotesDropdown.value;
            
            try {
                const backend_response = await fetch(`${ROSETTA_APP_BACKEND_URL}/generate_note`, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(payload) });
                const result = await backend_response.json();
                let statusMsg = backend_response.ok ? `Success: Note ${result.filename} ${result.message.includes("updated") ? "updated" : "created"}.` : `Error: ${result.error} (Details: ${result.details || 'N/A'})`;
                modelImpressionDisplayArea.value = `Status: ${statusMsg}\nPrompt Feedback: ${result.prompt_feedback || 'N/A'}\n\n--- Model Thoughts ---\n` + (result.llm_model_thoughts || "(No reasoning provided)");
                outputArea.value = result.llm_note_output || "(No note output)";
                if(backend_response.ok) { fetchExistingNotesRosetta(); displaySavedNotesList(); }
            } catch (error) {
                outputArea.value = `Network error or backend server issue.\nDetails: ${error.message}`;
                modelImpressionDisplayArea.value = `Network error. Ensure backend is running.`;
            }
        }
        
        const hideCheckbox = document.getElementById('hideTextCheckbox');
        const textAreasToHide = [ document.getElementById('patientInfoInput'), document.getElementById('epicSmartPhraseInput'), document.getElementById('modelImpressionArea'), document.getElementById('mainOutputArea') ];
        if (hideCheckbox) {
            hideCheckbox.addEventListener('change', function() {
                textAreasToHide.forEach(textArea => { if (textArea) textArea.classList.toggle('text-hidden-on-white', this.checked); });
            });
        }

        populatePredefinedTemplatesDropdown(); populateCheckboxOptions(); 
        const generateButton = document.getElementById('generatePromptButton');
        if (generateButton) generateButton.addEventListener('click', submitPromptToBackend); 
        
        const enableUpdateCheckbox = document.getElementById('enableUpdateModeCheckbox_rosetta');
        const notesControls = document.getElementById('existingNotesControls_rosetta');
        const refreshNotesListButton = document.getElementById('refreshNotesButton_rosetta'); 
        if (enableUpdateCheckbox && notesControls) {
            enableUpdateCheckbox.addEventListener('change', function() {
                notesControls.classList.toggle('hidden', !this.checked);
                if (this.checked) fetchExistingNotesRosetta(); 
            });
            if (!enableUpdateCheckbox.checked) notesControls.classList.add('hidden');
            const notesDropdown = document.getElementById('existingNotesDropdown_rosetta');
            if (notesDropdown) notesDropdown.addEventListener('change', function() { if (this.value) loadSelectedNoteContent(this.value); });
        }
        if (refreshNotesListButton) refreshNotesListButton.addEventListener('click', fetchExistingNotesRosetta);

        const saveChangesButton = document.getElementById('saveChangesToManualButton');
        const saveAsNewButton = document.getElementById('saveAsNewManualButton');

        if (saveChangesButton) {
            saveChangesButton.addEventListener('click', () => saveCustomTemplate(false)); // false means not a new file
        }
        if (saveAsNewButton) {
            saveAsNewButton.addEventListener('click', () => saveCustomTemplate(true)); // true means it's a new file
        }

        const clearTemplateBtn = document.getElementById('clearCustomTemplateButton');
        if (clearTemplateBtn) {
            clearTemplateBtn.addEventListener('click', () => { 
                const ta = document.getElementById('epicSmartPhraseInput'); 
                if(ta) ta.value = ''; 
                // Also reset editing state if custom area is cleared
                currentlyEditingManualFilename = null;
                if(saveChangesButton) {
                    saveChangesButton.classList.add('hidden');
                    saveChangesButton.disabled = true;
                }
                if(templateSelectorForEdit) templateSelectorForEdit.value = "none"; // Reset dropdown
                if(editManualButton) editManualButton.classList.add('hidden'); // Hide edit button
            });
        }

        async function deleteCustomTemplate() {
            const templateSelector = document.getElementById('templateSelector');
            const selectedTemplate = templateSelector.value;
            if (selectedTemplate === "none") { alert("Please select a template to delete."); return; }
            if (!confirm(`Delete template '${selectedTemplate}'?`)) return;
            try {
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/delete_smartphrase_template`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({ filename: `${selectedTemplate}.txt` }),
                });
                const result = await response.json();
                alert(response.ok ? `Template '${selectedTemplate}' deleted.` : `Error: ${result.error}`);
                if (response.ok) populatePredefinedTemplatesDropdown();
            } catch (error) { alert(`Network error: ${error.message}`); }
        }
        const deleteTemplateBtn = document.getElementById('deleteCustomTemplateButton'); // Assuming this button exists
        if (deleteTemplateBtn) deleteTemplateBtn.addEventListener('click', deleteCustomTemplate);

        const templateSection = document.getElementById('templateSection');
        if (templateSection) templateSection.addEventListener('toggle', function() { if (!this.open) populatePredefinedTemplatesDropdown(); });

        const copyButton = document.getElementById('copyNoteButton');
        const noteOutputArea = document.getElementById('mainOutputArea');
        if (copyButton && noteOutputArea) {
            copyButton.addEventListener('click', function() {
                if (!noteOutputArea.value) { alert("No note to copy."); return; }
                navigator.clipboard.writeText(noteOutputArea.value).then(() => {
                    const originalText = copyButton.innerHTML; copyButton.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    setTimeout(() => { copyButton.innerHTML = originalText; }, 2000);
                }).catch(err => alert('Failed to copy. Error: ' + err));
            });
        }

        displaySavedNotesList();
        const refreshServerNotesBtn = document.getElementById('refreshServerNotesListButton');
        if (refreshServerNotesBtn) refreshServerNotesBtn.addEventListener('click', displaySavedNotesList);

        async function deleteAllNotes() {
            if (!confirm("Delete ALL saved notes? This cannot be undone.")) return;
            try {
                const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/api/delete_all_notes`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({ confirm: true }) 
                });
                const result = await response.json();
                alert(response.ok ? (result.message || "All notes deleted.") : `Error: ${result.error || 'Unknown'}`);
                if (response.ok) { displaySavedNotesList(); fetchExistingNotesRosetta(); }
            } catch (error) { alert(`Network error: ${error.message}`); }
        }
        const deleteAllBtn = document.getElementById('deleteAllNotesButton');
        if (deleteAllBtn) deleteAllBtn.addEventListener('click', deleteAllNotes);

        const helpButton = document.getElementById('rosettaHelpButton');
        const docModal = document.getElementById('rosettaDocumentationModal');
        const docContent = document.getElementById('rosettaDocumentationContent');
        const closeDocModalBtn = document.getElementById('closeDocModalButton');
        async function openDocumentationModal() {
            if (docModal && docContent) {
                docModal.classList.remove('hidden');
                docContent.innerHTML = '<p>Loading documentation...</p>';
                try {
                    const response = await fetch('ROSETTA_DOCUMENTATION.md');
                    if (response.ok) {
                        const markdownText = await response.text();
                        if (typeof marked !== 'undefined') {
                            docContent.innerHTML = marked.parse(markdownText);
                        } else {
                            console.error("Marked.js library not loaded. Displaying raw Markdown.");
                            docContent.textContent = markdownText; 
                        }
                    } else {
                        docContent.innerHTML = `Error loading documentation: Status ${response.status}`;
                    }
                } catch (error) {
                    console.error('Error fetching documentation:', error);
                    docContent.innerHTML = `Error fetching documentation: ${error.message}`;
                }
            }
        }
        if (helpButton) helpButton.addEventListener('click', openDocumentationModal);
        if (closeDocModalBtn) closeDocModalBtn.addEventListener('click', () => { if (docModal) docModal.classList.add('hidden'); });
        document.addEventListener('keydown', function(event) {
            if (event.key === "Escape" && docModal && !docModal.classList.contains('hidden')) {
                docModal.classList.add('hidden');
            }
        });

        // Logic for "Edit Selected Manual" button
        const templateSelectorForEdit = document.getElementById('templateSelector');
        const editManualButton = document.getElementById('editSelectedManualButton');
        const deleteSelectedManualBtn = document.getElementById('deleteSelectedManualButton');
        const customTemplateTextarea = document.getElementById('epicSmartPhraseInput');
        const saveChangesBtn = document.getElementById('saveChangesToManualButton');

        // The initial state check is now handled within populatePredefinedTemplatesDropdown

        if (templateSelectorForEdit && editManualButton && customTemplateTextarea && saveChangesBtn && deleteSelectedManualBtn) {
            templateSelectorForEdit.addEventListener('change', function() {
                currentlyEditingManualFilename = null; // Reset on dropdown change
                saveChangesBtn.classList.add('hidden');
                saveChangesBtn.disabled = true;
                saveChangesBtn.textContent = 'Save Changes';


                if (this.value && this.value !== "none") {
                    editManualButton.classList.remove('hidden');
                    deleteSelectedManualBtn.classList.remove('hidden');
                } else {
                    editManualButton.classList.add('hidden');
                    deleteSelectedManualBtn.classList.add('hidden');
                }
            });

            editManualButton.addEventListener('click', async function() {
                const selectedTemplateValue = templateSelectorForEdit.value;
                if (!selectedTemplateValue || selectedTemplateValue === "none") {
                    alert("Please select a manual template to edit.");
                    return;
                }
                const templateFileName = `${selectedTemplateValue}.txt`;
                editManualButton.textContent = 'Loading...';
                editManualButton.disabled = true;
                try {
                    const response = await fetch(`smartphrase_templates/${templateFileName}`);
                    if (response.ok) {
                        const templateContent = await response.text();
                        customTemplateTextarea.value = templateContent;
                        currentlyEditingManualFilename = templateFileName; // Set the file being edited
                        saveChangesBtn.textContent = `Save Changes to ${selectedTemplateValue}`; // Update text
                        saveChangesBtn.classList.remove('hidden'); // Show button
                        saveChangesBtn.disabled = false; // Enable button
                        customTemplateTextarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    } else {
                        alert(`Error loading template '${templateFileName}': Status ${response.status}`);
                        customTemplateTextarea.value = `// Failed to load ${templateFileName}`;
                        currentlyEditingManualFilename = null;
                        saveChangesBtn.textContent = 'Save Changes'; // Reset text
                        saveChangesBtn.classList.add('hidden'); // Hide button
                        saveChangesBtn.disabled = true; // Disable button
                    }
                } catch (error) {
                    console.error('Error fetching manual template for editing:', error);
                    alert(`Error fetching template: ${error.message}`);
                    customTemplateTextarea.value = `// Error fetching ${templateFileName}: ${error.message}`;
                    currentlyEditingManualFilename = null;
                    saveChangesBtn.textContent = 'Save Changes'; // Reset text
                    saveChangesBtn.classList.add('hidden'); // Hide button
                    saveChangesBtn.disabled = true; // Disable button
                } finally {
                    editManualButton.textContent = 'Edit';
                    editManualButton.disabled = false;
                }
            });

            deleteSelectedManualBtn.addEventListener('click', async function() {
                const selectedTemplateValue = templateSelectorForEdit.value;
                if (!selectedTemplateValue || selectedTemplateValue === "none") {
                    alert("Please select a manual template to delete.");
                    return;
                }
                if (!confirm(`Are you sure you want to delete the manual template "${selectedTemplateValue}"? This cannot be undone.`)) {
                    return;
                }

                const templateFileName = `${selectedTemplateValue}.txt`;
                deleteSelectedManualBtn.textContent = 'Deleting...';
                deleteSelectedManualBtn.disabled = true;

                try {
                    const response = await fetch(`${ROSETTA_APP_BACKEND_URL}/delete_smartphrase_template`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filename: templateFileName }),
                    });
                    const result = await response.json();
                    if (response.ok) {
                        alert(`Template '${selectedTemplateValue}' deleted successfully.`);
                        populatePredefinedTemplatesDropdown(); // Refresh the list
                        customTemplateTextarea.value = ''; // Clear custom textarea
                        currentlyEditingManualFilename = null; // Reset editing state
                        saveChangesBtn.classList.add('hidden');
                        saveChangesBtn.disabled = true;
                        saveChangesBtn.textContent = 'Save Changes';
                        editManualButton.classList.add('hidden'); // Hide edit button as selection is gone
                        deleteSelectedManualBtn.classList.add('hidden'); // Hide delete button
                    } else {
                        alert(`Error deleting template: ${result.error || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error deleting manual template:', error);
                    alert(`Network error while deleting template: ${error.message}`);
                } finally {
                    deleteSelectedManualBtn.textContent = 'Delete';
                    deleteSelectedManualBtn.disabled = false;
                }
            });
        }
      }
    </script>

  <script>
    </script>
  </body>
</html>
<environment_details>
</environment_details>
